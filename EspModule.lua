local ESPModule = {}

-- Cleanup any existing ESP
do
    if ESP and ESP.Destroy then
        ESP:Destroy()
    end
    ESP = nil
    
    local CoreGui = game:GetService("CoreGui")
    local folder = CoreGui:FindFirstChild("Folder")
    if folder then
        for _, gui in ipairs(folder:GetChildren()) do
            if gui:IsA("ScreenGui") and gui.Name:find("ESP_") then
                gui:Destroy()
            end
        end
    end
end

-- Services
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")

-- Clean up any existing ESP instance
if _G.ESPInstance and _G.ESPInstance.Destroy then
    _G.ESPInstance:Destroy()
end

-- Create ESP class
ESP = {}
ESP.__index = ESP

-- Default settings with everything OFF
ESP.Settings = {
    Enabled = false, -- Start with ESP disabled
    Keybind = Enum.KeyCode.End,
    TestingMode = false,
    TeamCheck = false,
    MaxDistance = 3500,
    
    Box = {
        Enabled = false,
        Color = Color3.new(1, 1, 1),
        Thickness = 1,
        Transparency = 0,
        Filled = false,
        FilledTransparency = 0.25,
        Inset = 0.03,
        TeamColor = true,
        BoxGradient = false,
        BoxGradientSpin = false,
        GradientSpinSpeed = 4,
        Gradient = {
            Colors = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(1, 0.7, 0.8)),
                ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))
            }),
            Rotation = 90,
            TeamColorKeypoint = 0.5,
        },
    },
    
    Outline = {
        Enabled = false,
        Color = Color3.new(0, 0, 0),
        Thickness = 1,
        Transparency = 0,
    },
    
    HealthBar = {
        Enabled = false,
        Width = 2,
        Offset = 4,
        Smoothness = 0.1,
        Background = Color3.new(1, 1, 1),
        BackgroundTransparency = 0,
        OutlineColor = Color3.new(0, 0, 0),
        OutlineTransparency = 0,
        UseGradient = false,
        DynamicColor = false,
        DynamicColorHigh = Color3.new(0, 1, 0),
        DynamicColorMedium = Color3.new(1, 1, 0),
        DynamicColorLow = Color3.new(1, 0, 0),
        Gradient = {
            Colors = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(1, 0, 0.5)),
                ColorSequenceKeypoint.new(0.15, Color3.new(1, 0.412, 0.706)),
                ColorSequenceKeypoint.new(0.5, Color3.new(0.847, 0.749, 0.847)),
                ColorSequenceKeypoint.new(0.55, Color3.new(0.847, 0.749, 0.847)),
                ColorSequenceKeypoint.new(1, Color3.new(0.58, 0, 0.827))
            }),
            Rotation = 90,
            LerpAnimation = false,
            LerpSpeed = 0.028,
        },
    },
    
    ArmorBar = {
        Enabled = false,
        Width = 1,
        Offset = 3,
        Color = Color3.new(0, 0.5, 1),
        Background = Color3.new(0.2, 0.2, 0.3),
        BackgroundTransparency = 0,
        OutlineColor = Color3.new(0, 0, 0),
        OutlineTransparency = 0,
        MaxArmor = 130,
        UseGradient = false,
        ShowOnValue = true,
        Gradient = {
            Colors = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(0.9, 0.9, 1)),
                ColorSequenceKeypoint.new(0.3, Color3.new(0.7, 0.85, 1)),
                ColorSequenceKeypoint.new(0.6, Color3.new(0.4, 0.7, 1)),
                ColorSequenceKeypoint.new(1, Color3.new(0, 0.3, 0.8))
            }),
            Rotation = 90,
            LerpAnimation = false,
            LerpSpeed = 0.028,
        },
    },
    
    ArmorText = {
        Enabled = false,
        Size = 10,
        Offset = -1,
        Color = Color3.new(1, 1, 1),
        StaticColor = Color3.fromRGB(200, 220, 255),
        UseDynamicColor = false,
        Transparency = 0,
        ShowOutline = true,
        OutlineColor = Color3.new(0, 0, 0),
        OutlineTransparency = 0,
    },
    
    HealthText = {
        Enabled = false,
        Size = 10,
        Offset = 21,
        Color = Color3.new(1, 1, 1),
        StaticColor = Color3.fromRGB(255, 255, 255),
        UseDynamicColor = false,
        Transparency = 0,
        ShowOutline = true,
        OutlineColor = Color3.new(0, 0, 0),
        OutlineTransparency = 0,
        FollowBar = false,
    },
    
    VelocityFlag = {
        Enabled = false,
        Size = 10,
        Offset = 3,
        Color = Color3.new(1, 1, 1),
        StaticColor = Color3.fromRGB(255, 255, 255),
        Transparency = 0,
        ShowOutline = true,
        OutlineColor = Color3.new(0, 0, 0),
        OutlineTransparency = 0,
    },
    
    NameTag = {
        Enabled = false,
        Font = Enum.Font.SourceSansSemibold,
        Size = 12,
        Color = Color3.new(1, 1, 1),
        Transparency = 0,
        UseDisplayName = true,
        Offset = Vector2.new(0, -18),
        ShowOutline = true,
        OutlineColor = Color3.new(0, 0, 0),
        OutlineTransparency = 0,
    },
    
    Distance = {
        Enabled = false,
        Font = Enum.Font.DenkOne,
        Size = 12,
        Color = Color3.new(1, 1, 1),
        Transparency = 1,
        Offset = Vector2.new(0, 5),
        ShowOutline = true,
        OutlineColor = Color3.new(0, 0, 0),
        OutlineTransparency = 0,
    },
    
    Highlight = {
        Enabled = false,
        FillColor = Color3.new(1, 1, 1),
        FillTransparency = 0.95,
        OutlineColor = Color3.new(1, 1, 1),
        OutlineTransparency = 0.9,
        TeamColor = false,
        UseBoxColor = true,
    },
    
    Character = {
        ExcludeAccessories = true,
        MaxLimbDistance = 5,
    },
}

-- ESP Instance Variables
ESP.Players = {}
ESP.Connections = {}
ESP.HealthStates = {}
ESP.Highlights = {}
ESP.Gui = nil
ESP.Running = false
ESP.LoopConnection = nil
ESP.UpdateRate = 0
ESP.LastUpdate = 0
ESP.LastPositions = {}
ESP.GradientSpinStartTime = 0

-- Helper Functions
function ESP:GetHealthColor(percent)
    percent = math.clamp(percent, 0, 1)
    if percent < 0.5 then
        return Color3.new(1, 0, 0):Lerp(Color3.new(1, 1, 0), percent * 2)
    else
        return Color3.new(1, 1, 0):Lerp(Color3.new(0, 1, 0), (percent - 0.5) * 2)
    end
end

function ESP:GetArmorColor(percent)
    percent = math.clamp(percent, 0, 1)
    return self.Settings.ArmorBar.Color:Lerp(Color3.new(0, 1, 1), percent)
end

function ESP:CreateGui()
    if self.Gui and self.Gui.Parent then
        self.Gui:Destroy()
    end
    
    self.Gui = Instance.new("ScreenGui")
    self.Gui.Name = "ESP_" .. tostring(math.random(10000, 99999))
    self.Gui.DisplayOrder = 9e9
    self.Gui.ResetOnSpawn = false
    
    local folder = CoreGui:FindFirstChild("Folder")
    if folder then
        self.Gui.Parent = folder
    else
        self.Gui.Parent = gethui and gethui() or CoreGui
    end
end

function ESP:CreateHighlight(player)
    if not self.Settings.Highlight.Enabled then return nil end
    
    local highlight = Instance.new("Highlight")
    highlight.Name = "ESP_Highlight_" .. player.Name
    highlight.Adornee = nil
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.FillColor = self.Settings.Highlight.FillColor
    highlight.FillTransparency = self.Settings.Highlight.FillTransparency
    highlight.OutlineColor = self.Settings.Highlight.OutlineColor
    highlight.OutlineTransparency = self.Settings.Highlight.OutlineTransparency
    highlight.Enabled = false
    
    local char = player.Character
    if char then
        highlight.Adornee = char
        highlight.Parent = char
        highlight.Enabled = true
    else
        highlight.Parent = nil
    end
    
    return highlight
end

function ESP:UpdateHighlight(player, highlight)
    if not highlight or not self.Settings.Highlight.Enabled then return end
    
    local char = player.Character
    if char and char:IsDescendantOf(Workspace) then
        if highlight.Adornee ~= char then
            highlight.Adornee = char
        end
        
        if highlight.Parent ~= char then
            highlight.Parent = char
        end
        
        if not highlight.Enabled then
            highlight.Enabled = true
        end
        
        -- Update highlight colors
        local teamColor = player.Team and player.Team.TeamColor.Color or self.Settings.Highlight.FillColor
        
        if self.Settings.Highlight.TeamColor then
            highlight.FillColor = teamColor
            if self.Settings.Highlight.UseBoxColor then
                highlight.OutlineColor = teamColor
            else
                highlight.OutlineColor = self.Settings.Highlight.OutlineColor
            end
        else
            highlight.FillColor = self.Settings.Highlight.FillColor
            highlight.OutlineColor = self.Settings.Highlight.OutlineColor
        end
        
        highlight.FillTransparency = self.Settings.Highlight.FillTransparency
        highlight.OutlineTransparency = self.Settings.Highlight.OutlineTransparency
    else
        highlight.Enabled = false
        highlight.Adornee = nil
    end
end

function ESP:CleanupPlayer(player)
    if self.Players[player] then
        for _, obj in pairs(self.Players[player]) do
            if typeof(obj) == "Instance" then
                obj:Destroy()
            end
        end
        self.Players[player] = nil
    end
    
    if self.Highlights[player] then
        local highlight = self.Highlights[player]
        highlight:Destroy()
        self.Highlights[player] = nil
    end
    
    self.LastPositions[player] = nil
end

local PopInInfo = TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
function ESP:AnimatePopIn(label)
    if not self.Running then return end
    label.TextSize = 1
    label.TextTransparency = 1
    TweenService:Create(label, PopInInfo, {TextSize = label.TextSize, TextTransparency = 0}):Play()
end

function ESP:CreateBox(player)
    local box = {}
    
    local teamColor = player.Team and player.Team.TeamColor.Color or self.Settings.Box.Color
    local boxColor = self.Settings.Box.TeamColor and teamColor or self.Settings.Box.Color
    
    local colors = {self.Settings.Outline.Color, boxColor, self.Settings.Outline.Color}
    local names = {"Outer", "Main", "Inner"}
    
    for i = 1, 3 do
        local frame = Instance.new("Frame")
        frame.Name = names[i]
        frame.BackgroundTransparency = 1
        frame.Visible = false
        frame.Parent = self.Gui
        
        local stroke = Instance.new("UIStroke")
        stroke.Color = colors[i]
        stroke.Thickness = i == 2 and self.Settings.Box.Thickness or self.Settings.Outline.Thickness
        stroke.Transparency = i == 2 and self.Settings.Box.Transparency or self.Settings.Outline.Transparency
        stroke.Parent = frame
        
        if self.Settings.Box.Filled and i == 2 then
            frame.BackgroundColor3 = boxColor
            frame.BackgroundTransparency = self.Settings.Box.FilledTransparency
        end
        
        if i == 2 and self.Settings.Box.BoxGradient then
            local gradient = Instance.new("UIGradient")
            gradient.Rotation = self.Settings.Box.Gradient.Rotation
            gradient.Parent = stroke
            box.BoxGradient = gradient
        end
        
        box[names[i]] = frame
    end
    
    -- Health Bar
    if self.Settings.HealthBar.Enabled then
        local healthBg = Instance.new("Frame")
        healthBg.Name = "HealthBg"
        healthBg.BackgroundColor3 = self.Settings.HealthBar.Background
        healthBg.BackgroundTransparency = self.Settings.HealthBar.BackgroundTransparency
        healthBg.BorderSizePixel = 0
        healthBg.Visible = false
        healthBg.Parent = self.Gui
        
        if self.Settings.HealthBar.UseGradient then
            local gradient = Instance.new("UIGradient")
            gradient.Color = self.Settings.HealthBar.Gradient.Colors
            gradient.Rotation = self.Settings.HealthBar.Gradient.Rotation
            gradient.Parent = healthBg
            box.HealthGradient = gradient
        else
            healthBg.BackgroundColor3 = self.Settings.HealthBar.Background
        end
        
        local healthMask = Instance.new("Frame")
        healthMask.Name = "HealthMask"
        healthMask.BackgroundColor3 = Color3.new(0, 0, 0)
        healthMask.BackgroundTransparency = 0
        healthMask.BorderSizePixel = 0
        healthMask.Parent = healthBg
        healthMask.ZIndex = healthBg.ZIndex + 1
        
        local healthBgStroke = Instance.new("UIStroke")
        healthBgStroke.Color = self.Settings.HealthBar.OutlineColor
        healthBgStroke.Thickness = 1
        healthBgStroke.Transparency = self.Settings.HealthBar.OutlineTransparency
        healthBgStroke.Parent = healthBg
        
        box.HealthBg = healthBg
        box.HealthMask = healthMask
    end
    
    -- Armor Bar
    if self.Settings.ArmorBar.Enabled then
        local armorBg = Instance.new("Frame")
        armorBg.Name = "ArmorBg"
        armorBg.BackgroundColor3 = self.Settings.ArmorBar.Background
        armorBg.BackgroundTransparency = self.Settings.ArmorBar.BackgroundTransparency
        armorBg.BorderSizePixel = 0
        armorBg.Visible = false
        armorBg.Parent = self.Gui
        
        local armorFill = Instance.new("Frame")
        armorFill.Name = "ArmorFill"
        armorFill.BackgroundColor3 = self.Settings.ArmorBar.Color
        armorFill.BackgroundTransparency = 0
        armorFill.BorderSizePixel = 0
        armorFill.Parent = armorBg
        armorFill.ZIndex = armorBg.ZIndex + 1
        
        if self.Settings.ArmorBar.UseGradient then
            local armorGradient = Instance.new("UIGradient")
            armorGradient.Color = self.Settings.ArmorBar.Gradient.Colors
            armorGradient.Rotation = self.Settings.ArmorBar.Gradient.Rotation
            armorGradient.Parent = armorFill
            box.ArmorGradient = armorGradient
        end
        
        local armorMask = Instance.new("Frame")
        armorMask.Name = "ArmorMask"
        armorMask.BackgroundColor3 = Color3.new(0, 0, 0)
        armorMask.BackgroundTransparency = 0.3
        armorMask.BorderSizePixel = 0
        armorMask.Parent = armorBg
        armorMask.ZIndex = armorBg.ZIndex + 2
        
        local armorBgStroke = Instance.new("UIStroke")
        armorBgStroke.Color = self.Settings.ArmorBar.OutlineColor
        armorBgStroke.Thickness = 1
        armorBgStroke.Transparency = self.Settings.ArmorBar.OutlineTransparency
        armorBgStroke.Parent = armorBg
        
        box.ArmorBg = armorBg
        box.ArmorFill = armorFill
        box.ArmorMask = armorMask
    end
    
    -- Name Tag
    if self.Settings.NameTag.Enabled then
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Name = "NameLabel"
        nameLabel.BackgroundTransparency = 1
        nameLabel.Text = ""
        nameLabel.TextColor3 = self.Settings.NameTag.Color
        nameLabel.TextSize = self.Settings.NameTag.Size
        nameLabel.Font = self.Settings.NameTag.Font
        nameLabel.TextTransparency = self.Settings.NameTag.Transparency
        nameLabel.TextStrokeTransparency = self.Settings.NameTag.ShowOutline and self.Settings.NameTag.OutlineTransparency or 1
        nameLabel.TextStrokeColor3 = self.Settings.NameTag.OutlineColor
        nameLabel.Visible = false
        nameLabel.Parent = self.Gui
        box.NameLabel = nameLabel
    end
    
    -- Health Text
    if self.Settings.HealthText.Enabled then
        local healthText = Instance.new("TextLabel")
        healthText.Name = "HealthText"
        healthText.BackgroundTransparency = 1
        healthText.Text = ""
        healthText.TextColor3 = self.Settings.HealthText.StaticColor
        healthText.TextSize = self.Settings.HealthText.Size
        healthText.Font = Enum.Font.SourceSans
        healthText.TextTransparency = self.Settings.HealthText.Transparency
        healthText.TextStrokeTransparency = self.Settings.HealthText.ShowOutline and self.Settings.HealthText.OutlineTransparency or 1
        healthText.TextStrokeColor3 = self.Settings.HealthText.OutlineColor
        healthText.TextXAlignment = Enum.TextXAlignment.Right
        healthText.Visible = false
        healthText.Parent = self.Gui
        box.HealthText = healthText
    end
    
    -- Armor Text
    if self.Settings.ArmorText.Enabled then
        local armorText = Instance.new("TextLabel")
        armorText.Name = "ArmorText"
        armorText.BackgroundTransparency = 1
        armorText.Text = ""
        armorText.TextColor3 = self.Settings.ArmorText.StaticColor
        armorText.TextSize = self.Settings.ArmorText.Size
        armorText.Font = Enum.Font.SourceSans
        armorText.TextTransparency = self.Settings.ArmorText.Transparency
        armorText.TextStrokeTransparency = self.Settings.ArmorText.ShowOutline and self.Settings.ArmorText.OutlineTransparency or 1
        armorText.TextStrokeColor3 = self.Settings.ArmorText.OutlineColor
        armorText.TextXAlignment = Enum.TextXAlignment.Right
        armorText.Visible = false
        armorText.Parent = self.Gui
        box.ArmorText = armorText
    end
    
    -- Velocity Flag
    if self.Settings.VelocityFlag.Enabled then
        local velocityFlag = Instance.new("TextLabel")
        velocityFlag.Name = "VelocityFlag"
        velocityFlag.BackgroundTransparency = 1
        velocityFlag.Text = ""
        velocityFlag.TextColor3 = self.Settings.VelocityFlag.StaticColor
        velocityFlag.TextSize = self.Settings.VelocityFlag.Size
        velocityFlag.Font = Enum.Font.SourceSansBold
        velocityFlag.TextTransparency = self.Settings.VelocityFlag.Transparency
        velocityFlag.TextStrokeTransparency = self.Settings.VelocityFlag.ShowOutline and self.Settings.VelocityFlag.OutlineTransparency or 1
        velocityFlag.TextStrokeColor3 = self.Settings.VelocityFlag.OutlineColor
        velocityFlag.TextXAlignment = Enum.TextXAlignment.Left
        velocityFlag.Visible = false
        velocityFlag.Parent = self.Gui
        box.VelocityFlag = velocityFlag
    end
    
    -- Distance
    if self.Settings.Distance.Enabled then
        local distanceLabel = Instance.new("TextLabel")
        distanceLabel.Name = "DistanceLabel"
        distanceLabel.BackgroundTransparency = 1
        distanceLabel.Text = ""
        distanceLabel.TextColor3 = self.Settings.Distance.Color
        distanceLabel.TextSize = self.Settings.Distance.Size
        distanceLabel.Font = self.Settings.Distance.Font
        distanceLabel.TextTransparency = self.Settings.Distance.Transparency
        distanceLabel.TextStrokeTransparency = self.Settings.Distance.ShowOutline and self.Settings.Distance.OutlineTransparency or 1
        distanceLabel.TextStrokeColor3 = self.Settings.Distance.OutlineColor
        distanceLabel.TextXAlignment = Enum.TextXAlignment.Center
        distanceLabel.Visible = false
        distanceLabel.Parent = self.Gui
        box.DistanceLabel = distanceLabel
    end
    
    box.VisualHealth = 1
    box.VisualArmor = 0
    
    return box
end

function ESP:GetBoxGradientColors(player)
    if not self.Settings.Box.BoxGradient then
        return nil
    end
    
    local gradientSettings = self.Settings.Box.Gradient
    
    if self.Settings.Box.TeamColor then
        local teamColor = player.Team and player.Team.TeamColor.Color or self.Settings.Box.Color
        local teamKeypoint = gradientSettings.TeamColorKeypoint or 0.5
        local baseSequence = gradientSettings.Colors
        
        local keypoints = {}
        
        for _, kp in ipairs(baseSequence.Keypoints) do
            table.insert(keypoints, ColorSequenceKeypoint.new(kp.Time, kp.Value))
        end
        
        table.insert(keypoints, ColorSequenceKeypoint.new(teamKeypoint, teamColor))
        
        table.sort(keypoints, function(a, b)
            return a.Time < b.Time
        end)
        
        return ColorSequence.new(keypoints)
    else
        return gradientSettings.Colors
    end
end

function ESP:CalculateGradientSpinRotation()
    if not self.Settings.Box.BoxGradient or not self.Settings.Box.BoxGradientSpin then
        return self.Settings.Box.Gradient.Rotation
    end
    
    if self.GradientSpinStartTime == 0 then
        self.GradientSpinStartTime = tick()
    end
    
    local elapsedTime = tick() - self.GradientSpinStartTime
    local rotationSpeed = self.Settings.Box.GradientSpinSpeed > 0 and self.Settings.Box.GradientSpinSpeed or 1
    local rotation = (elapsedTime / rotationSpeed * 360) % 360
    
    return rotation
end

function ESP:SetBoxVisible(box, visible)
    if not box then return end
    
    if self.Settings.Box.Enabled then
        if box.Outer then box.Outer.Visible = visible end
        if box.Main then box.Main.Visible = visible end
        if box.Inner then box.Inner.Visible = visible end
    end
    
    if self.Settings.HealthBar.Enabled and box.HealthBg then
        box.HealthBg.Visible = visible
    end
    
    if self.Settings.ArmorBar.Enabled and box.ArmorBg then
        box.ArmorBg.Visible = visible
    end
    
    if self.Settings.NameTag.Enabled and box.NameLabel then
        box.NameLabel.Visible = visible
    end
    
    if self.Settings.HealthText.Enabled and box.HealthText then
        box.HealthText.Visible = visible
    end
    
    if self.Settings.ArmorText.Enabled and box.ArmorText then
        box.ArmorText.Visible = visible
    end
    
    if self.Settings.VelocityFlag.Enabled and box.VelocityFlag then
        box.VelocityFlag.Visible = visible
    end
    
    -- FIXED: Include distance label in visibility control
    if self.Settings.Distance.Enabled and box.DistanceLabel then
        box.DistanceLabel.Visible = visible
    end
end

function ESP:GetCharacterCenter(char)
    if not char then return nil end
    
    local parts = {}
    for _, part in ipairs(char:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            table.insert(parts, part)
        end
    end
    
    if #parts == 0 then
        return nil
    end
    
    local totalX, totalY, totalZ = 0, 0, 0
    for _, part in ipairs(parts) do
        totalX = totalX + part.Position.X
        totalY = totalY + part.Position.Y
        totalZ = totalZ + part.Position.Z
    end
    
    return Vector3.new(totalX / #parts, totalY / #parts, totalZ / #parts)
end

function ESP:GetCharacterBoundingBox(char)
    if not char then return nil end
    
    local parts = {}
    for _, part in ipairs(char:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            if not self.Settings.Character.ExcludeAccessories or not part:IsA("Accoutrement") then
                table.insert(parts, part)
            end
        end
    end
    
    if #parts == 0 then
        return nil
    end
    
    local minX, minY, minZ = math.huge, math.huge, math.huge
    local maxX, maxY, maxZ = -math.huge, -math.huge, -math.huge
    
    for _, part in ipairs(parts) do
        local size = part.Size
        local position = part.Position
        local halfSize = size / 2
        
        minX = math.min(minX, position.X - halfSize.X)
        minY = math.min(minY, position.Y - halfSize.Y)
        minZ = math.min(minZ, position.Z - halfSize.Z)
        
        maxX = math.max(maxX, position.X + halfSize.X)
        maxY = math.max(maxY, position.Y + halfSize.Y)
        maxZ = math.max(maxZ, position.Z + halfSize.Z)
    end
    
    local centerX = (minX + maxX) / 2
    local centerY = (minY + maxY) / 2
    local centerZ = (minZ + maxZ) / 2
    local centerPos = Vector3.new(centerX, centerY, centerZ)
    
    local newMinX, newMinY, newMinZ = math.huge, math.huge, math.huge
    local newMaxX, newMaxY, newMaxZ = -math.huge, -math.huge, -math.huge
    local anyValid = false
    
    for _, part in ipairs(parts) do
        local distance = (part.Position - centerPos).Magnitude
        if distance <= self.Settings.Character.MaxLimbDistance then
            anyValid = true
            local size = part.Size
            local position = part.Position
            local halfSize = size / 2
            
            newMinX = math.min(newMinX, position.X - halfSize.X)
            newMinY = math.min(newMinY, position.Y - halfSize.Y)
            newMinZ = math.min(newMinZ, position.Z - halfSize.Z)
            
            newMaxX = math.max(newMaxX, position.X + halfSize.X)
            newMaxY = math.max(newMaxY, position.Y + halfSize.Y)
            newMaxZ = math.max(newMaxZ, position.Z + halfSize.Z)
        end
    end
    
    if not anyValid then
        newMinX, newMinY, newMinZ = minX, minY, minZ
        newMaxX, newMaxY, newMaxZ = maxX, maxY, maxZ
    end
    
    local buffer = 0.1
    newMinX = newMinX - buffer
    newMinY = newMinY - buffer
    newMinZ = newMinZ - buffer
    newMaxX = newMaxX + buffer
    newMaxY = newMaxY + buffer
    newMaxZ = newMaxZ + buffer
    
    local center = Vector3.new((newMinX + newMaxX) / 2, (newMinY + newMaxY) / 2, (newMinZ + newMaxZ) / 2)
    local size = Vector3.new(newMaxX - newMinX, newMaxY - newMinY, newMaxZ - newMinZ)
    
    if size.Magnitude < 0.1 then
        return nil
    end
    
    return CFrame.new(center), size
end

function ESP:GetPlayerArmor(player)
    local success, armorValue = pcall(function()
        local playerFolder = Workspace:FindFirstChild("Players")
        if not playerFolder then return 0 end
        
        local playerModel = playerFolder:FindFirstChild(player.Name)
        if not playerModel then return 0 end
        
        local bodyEffects = playerModel:FindFirstChild("BodyEffects")
        if not bodyEffects then return 0 end
        
        local armor = bodyEffects:FindFirstChild("Armor")
        if not armor then return 0 end
        
        if armor:IsA("NumberValue") or armor:IsA("IntValue") or armor:IsA("ValueBase") then
            return tonumber(armor.Value) or 0
        end
        
        return 0
    end)
    
    if success then
        return math.clamp(armorValue, 0, self.Settings.ArmorBar.MaxArmor)
    end
    
    return 0
end

function ESP:CalculateVelocity(player, charCenter)
    local now = tick()
    local lastPosition = self.LastPositions[player]
    
    if not lastPosition then
        self.LastPositions[player] = {
            position = charCenter,
            time = now
        }
        return 0
    end
    
    local timeDelta = now - lastPosition.time
    if timeDelta < 0.01 then
        return math.floor(lastPosition.velocity or 0)
    end
    
    local distance = (charCenter - lastPosition.position).Magnitude
    local velocity = distance / timeDelta
    
    local velocityInt = math.floor(velocity)
    
    self.LastPositions[player] = {
        position = charCenter,
        time = now,
        velocity = velocityInt
    }
    
    return velocityInt
end

function ESP:ShouldShowArmorBar(player)
    if not self.Settings.ArmorBar.Enabled then
        return false
    end
    
    if not self.Settings.ArmorBar.ShowOnValue then
        return true
    end
    
    local armorValue = 0
    if self.Settings.TestingMode and player == LocalPlayer then
        armorValue = math.floor(math.abs(math.sin(tick() * 0.5)) * self.Settings.ArmorBar.MaxArmor)
    else
        armorValue = self:GetPlayerArmor(player)
    end
    
    return armorValue > 0
end

function ESP:Update()
    if not self.Running or not self.Settings.Enabled then
        if self.Gui then
            self.Gui.Enabled = false
        end
        
        -- Disable all highlights when ESP is disabled
        for player, highlight in pairs(self.Highlights) do
            if highlight then
                highlight.Enabled = false
            end
        end
        return
    end
    
    local now = tick()
    if now - self.LastUpdate < self.UpdateRate then
        return
    end
    self.LastUpdate = now
    
    if self.Gui then
        self.Gui.Enabled = true
    end
    
    local localChar = LocalPlayer.Character
    local localTeam = LocalPlayer.Team
    
    local playersToProcess = {}
    
    if self.Settings.TestingMode then
        table.insert(playersToProcess, LocalPlayer)
    end
    
    for _, player in ipairs(Players:GetPlayers()) do
        if not self.Running then break end
        table.insert(playersToProcess, player)
    end
    
    for _, player in ipairs(playersToProcess) do
        if not self.Running then break end
        
        local skipCheck = (player == LocalPlayer and self.Settings.TestingMode)
        
        if not skipCheck and player == LocalPlayer then
            self:CleanupPlayer(player)
            continue
        end
        
        if not skipCheck and self.Settings.TeamCheck and player.Team == localTeam then
            self:CleanupPlayer(player)
            continue
        end
        
        local char = player.Character
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        
        local anyBodyPart = char and (char:FindFirstChild("Head") or char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso"))
        
        if not char or not anyBodyPart or not humanoid or humanoid.Health <= 0 then
            self:CleanupPlayer(player)
            continue
        end
        
        local charCenter = self:GetCharacterCenter(char)
        local localCenter = self:GetCharacterCenter(localChar)
        
        -- Calculate distance regardless of on-screen status
        local distance = 0
        if localCenter then
            distance = math.floor((localCenter - charCenter).Magnitude)
        end
        
        -- Distance check for max range
        if not skipCheck and localCenter and distance > self.Settings.MaxDistance then
            self:CleanupPlayer(player)
            continue
        end
        
        local box = self.Players[player]
        local highlight = self.Highlights[player]
        
        -- Update highlight if enabled
        if self.Settings.Highlight.Enabled then
            if not highlight then
                highlight = self:CreateHighlight(player)
                if highlight then
                    self.Highlights[player] = highlight
                end
            else
                self:UpdateHighlight(player, highlight)
            end
        elseif highlight then
            highlight.Enabled = false
        end
        
        local cframe, size = self:GetCharacterBoundingBox(char)
        if not cframe then
            self:CleanupPlayer(player)
            continue
        end
        
        -- Check if character is on screen
        local onScreen = false
        local left, top, right, bottom = 0, 0, 0, 0
        
        local halfSize = size / 2
        local corners = {
            cframe * Vector3.new(halfSize.X, halfSize.Y, halfSize.Z),
            cframe * Vector3.new(halfSize.X, halfSize.Y, -halfSize.Z),
            cframe * Vector3.new(halfSize.X, -halfSize.Y, halfSize.Z),
            cframe * Vector3.new(halfSize.X, -halfSize.Y, -halfSize.Z),
            cframe * Vector3.new(-halfSize.X, halfSize.Y, halfSize.Z),
            cframe * Vector3.new(-halfSize.X, halfSize.Y, -halfSize.Z),
            cframe * Vector3.new(-halfSize.X, -halfSize.Y, halfSize.Z),
            cframe * Vector3.new(-halfSize.X, -halfSize.Y, -halfSize.Z)
        }
        
        for _, corner in ipairs(corners) do
            local screenPos, visible = Camera:WorldToScreenPoint(corner)
            if visible and screenPos.Z > 0 then
                onScreen = true
                left = math.min(left, screenPos.X)
                top = math.min(top, screenPos.Y)
                right = math.max(right, screenPos.X)
                bottom = math.max(bottom, screenPos.Y)
            end
        end
        
        -- Get health and armor info
        local healthPercent, healthValue = 0, 0
        if self.Settings.TestingMode and player == LocalPlayer then
            local time = tick()
            healthPercent = (math.sin(time * 2) + 1) / 2
            healthValue = math.floor(healthPercent * 100)
        else
            healthPercent = humanoid.Health / humanoid.MaxHealth
            healthValue = math.floor(humanoid.Health)
        end
        
        if onScreen then
            left = math.floor(left)
            top = math.floor(top)
            right = math.ceil(right)
            bottom = math.ceil(bottom)
            
            local inset = (bottom - top) * self.Settings.Box.Inset
            left = left + inset
            top = top + inset
            right = right - inset
            bottom = bottom - inset
            
            local width = right - left
            local height = bottom - top
            local boxTopY = top - 1
            local totalBoxHeight = height + 2
            
            if not box then
                box = self:CreateBox(player)
                self.Players[player] = box
                if self.Settings.Distance.Enabled and box.DistanceLabel then
                    self:AnimatePopIn(box.DistanceLabel)
                end
            end
            
            -- Update box visibility based on settings
            if self.Settings.Box.Enabled and box.Main then
                if box.Outer then
                    box.Outer.Position = UDim2.new(0, left - 1, 0, boxTopY)
                    box.Outer.Size = UDim2.new(0, width + 2, 0, totalBoxHeight)
                    box.Outer.Visible = true
                end
                
                if box.Main then
                    box.Main.Position = UDim2.new(0, left, 0, top)
                    box.Main.Size = UDim2.new(0, width, 0, height)
                    box.Main.Visible = true
                end
                
                if box.Inner then
                    box.Inner.Position = UDim2.new(0, left + 1, 0, top + 1)
                    box.Inner.Size = UDim2.new(0, width - 2, 0, height - 2)
                    box.Inner.Visible = true
                end
                
                local teamColor = player.Team and player.Team.TeamColor.Color or self.Settings.Box.Color
                local boxColor = self.Settings.Box.TeamColor and not (skipCheck and player == LocalPlayer) and teamColor or self.Settings.Box.Color
                
                if self.Settings.Box.BoxGradient and box.BoxGradient then
                    local gradientColors = self:GetBoxGradientColors(player)
                    if gradientColors then
                        box.BoxGradient.Color = gradientColors
                        local rotation = self:CalculateGradientSpinRotation()
                        box.BoxGradient.Rotation = rotation
                        if box.Main and box.Main:FindFirstChild("UIStroke") then
                            box.Main.UIStroke.Color = Color3.new(1, 1, 1)
                        end
                    end
                else
                    if box.Main and box.Main:FindFirstChild("UIStroke") then
                        box.Main.UIStroke.Color = boxColor
                    end
                    if box.Main and self.Settings.Box.Filled then
                        box.Main.BackgroundColor3 = boxColor
                    end
                end
                
                if box.Main and box.Main:FindFirstChild("UIStroke") then
                    box.Main.UIStroke.Thickness = self.Settings.Box.Thickness
                end
            else
                if box.Outer then box.Outer.Visible = false end
                if box.Main then box.Main.Visible = false end
                if box.Inner then box.Inner.Visible = false end
            end
            
            local healthState = self.HealthStates[player]
            if not healthState then
                healthState = {health = healthPercent}
                self.HealthStates[player] = healthState
            end
            
            if self.Settings.HealthBar.Gradient.LerpAnimation and self.Settings.HealthBar.UseGradient then
                healthState.health = healthState.health + (healthPercent - healthState.health) * self.Settings.HealthBar.Gradient.LerpSpeed
                box.VisualHealth = healthState.health
            else
                box.VisualHealth = healthPercent
            end
            
            local armorValue = 0
            local armorPercent = 0
            if self.Settings.TestingMode and player == LocalPlayer then
                local time = tick()
                armorPercent = (math.sin(time * 2 + 1) + 1) / 2
                armorValue = math.floor(armorPercent * self.Settings.ArmorBar.MaxArmor)
            else
                armorValue = self:GetPlayerArmor(player)
                armorPercent = armorValue / self.Settings.ArmorBar.MaxArmor
            end
            
            if self.Settings.ArmorBar.Gradient.LerpAnimation then
                box.VisualArmor = box.VisualArmor + (armorPercent - box.VisualArmor) * self.Settings.ArmorBar.Gradient.LerpSpeed
            else
                box.VisualArmor = box.VisualArmor + (armorPercent - box.VisualArmor) * 0.1
            end
            
            local shouldShowArmorBar = self:ShouldShowArmorBar(player)
            
            local totalBarWidth = 0
            local armorBarX = 0
            local healthBarX = 0
            
            if shouldShowArmorBar then
                totalBarWidth = totalBarWidth + self.Settings.ArmorBar.Width + self.Settings.ArmorBar.Offset
            end
            
            if self.Settings.HealthBar.Enabled then
                totalBarWidth = totalBarWidth + self.Settings.HealthBar.Width + self.Settings.HealthBar.Offset
            end
            
            -- Health Bar
            if self.Settings.HealthBar.Enabled and box.HealthBg then
                if shouldShowArmorBar then
                    healthBarX = left - (self.Settings.HealthBar.Width + self.Settings.HealthBar.Offset)
                else
                    healthBarX = left - (self.Settings.HealthBar.Width + self.Settings.HealthBar.Offset)
                end
                
                box.HealthBg.Position = UDim2.new(0, healthBarX, 0, boxTopY)
                box.HealthBg.Size = UDim2.new(0, self.Settings.HealthBar.Width, 0, totalBoxHeight)
                box.HealthBg.Visible = true
                
                local maskHeight = totalBoxHeight * (1 - box.VisualHealth)
                box.HealthMask.Size = UDim2.new(1, 0, 0, maskHeight)
                
                if not self.Settings.HealthBar.UseGradient and self.Settings.HealthBar.DynamicColor then
                    local dynamicColor = self:GetHealthColor(healthPercent)
                    box.HealthBg.BackgroundColor3 = dynamicColor
                elseif not self.Settings.HealthBar.UseGradient then
                    box.HealthBg.BackgroundColor3 = self.Settings.HealthBar.Background
                end
            elseif box.HealthBg then
                box.HealthBg.Visible = false
            end
            
            -- Armor Bar
            if shouldShowArmorBar and box.ArmorBg then
                armorBarX = left - totalBarWidth
                box.ArmorBg.Position = UDim2.new(0, armorBarX, 0, boxTopY)
                box.ArmorBg.Size = UDim2.new(0, self.Settings.ArmorBar.Width, 0, totalBoxHeight)
                box.ArmorBg.Visible = true
                
                local armorFillHeight = totalBoxHeight * box.VisualArmor
                box.ArmorFill.Position = UDim2.new(0, 0, 0, totalBoxHeight - armorFillHeight)
                box.ArmorFill.Size = UDim2.new(1, 0, 0, armorFillHeight)
                
                local armorMaskHeight = totalBoxHeight * (1 - box.VisualArmor)
                box.ArmorMask.Size = UDim2.new(1, 0, 0, armorMaskHeight)
                
                if not self.Settings.ArmorBar.UseGradient then
                    box.ArmorFill.BackgroundColor3 = self:GetArmorColor(box.VisualArmor)
                end
            elseif box.ArmorBg then
                box.ArmorBg.Visible = false
            end
            
            -- Name Tag
            if self.Settings.NameTag.Enabled and box.NameLabel then
                if self.Settings.TestingMode and player == LocalPlayer then
                    box.NameLabel.Text = "[TEST] " .. (self.Settings.NameTag.UseDisplayName and player.DisplayName or player.Name)
                else
                    box.NameLabel.Text = self.Settings.NameTag.UseDisplayName and player.DisplayName or player.Name
                end
                box.NameLabel.Position = UDim2.new(0, left - 1, 0, top - 18)
                box.NameLabel.Size = UDim2.new(0, width + 2, 0, self.Settings.NameTag.Size + 4)
                box.NameLabel.TextColor3 = self.Settings.NameTag.Color
                box.NameLabel.TextSize = self.Settings.NameTag.Size
                box.NameLabel.Visible = true
            elseif box.NameLabel then
                box.NameLabel.Visible = false
            end
            
            -- Health Text
            if self.Settings.HealthText.Enabled and box.HealthText then
                if self.Settings.TestingMode and player == LocalPlayer then
                    box.HealthText.Text = tostring(healthValue) .. "%"
                else
                    box.HealthText.Text = tostring(healthValue)
                end
                
                if self.Settings.HealthText.UseDynamicColor then
                    box.HealthText.TextColor3 = self:GetHealthColor(healthPercent)
                else
                    box.HealthText.TextColor3 = self.Settings.HealthText.StaticColor
                end
                
                local healthTextX = 0
                
                if shouldShowArmorBar then
                    healthTextX = left - totalBarWidth - self.Settings.HealthText.Offset
                else
                    healthTextX = left - (self.Settings.HealthBar.Width + self.Settings.HealthBar.Offset) - self.Settings.HealthText.Offset
                end
                
                if self.Settings.HealthText.FollowBar then
                    local maskHeight = totalBoxHeight * (1 - box.VisualHealth)
                    local healthTextY = boxTopY + maskHeight + 3 - (self.Settings.HealthText.Size / 2)
                    box.HealthText.Position = UDim2.new(0, healthTextX, 0, healthTextY)
                else
                    local healthTextY = boxTopY + (totalBoxHeight * 0.001) - (self.Settings.HealthText.Size / 2)
                    box.HealthText.Position = UDim2.new(0, healthTextX, 0, healthTextY)
                end
                
                box.HealthText.Size = UDim2.new(0, 18, 0, self.Settings.HealthText.Size + 4)
                box.HealthText.TextSize = self.Settings.HealthText.Size
                box.HealthText.Visible = true
            elseif box.HealthText then
                box.HealthText.Visible = false
            end
            
            -- Armor Text
            if self.Settings.ArmorText.Enabled and box.ArmorText and shouldShowArmorBar then
                box.ArmorText.Text = tostring(armorValue)
                
                if self.Settings.ArmorText.UseDynamicColor then
                    box.ArmorText.TextColor3 = self:GetArmorColor(armorPercent)
                else
                    box.ArmorText.TextColor3 = self.Settings.ArmorText.StaticColor
                end
                
                local armorTextX = 0
                
                if shouldShowArmorBar then
                    armorTextX = left - totalBarWidth - self.Settings.HealthText.Offset
                else
                    armorTextX = left - (self.Settings.HealthBar.Width + self.Settings.HealthBar.Offset) - self.Settings.HealthText.Offset
                end
                
                local armorTextY = 0
                if self.Settings.HealthText.Enabled then
                    armorTextY = box.HealthText.Position.Y.Offset + self.Settings.HealthText.Size + self.Settings.ArmorText.Offset
                else
                    if self.Settings.HealthText.FollowBar then
                        local maskHeight = totalBoxHeight * (1 - box.VisualHealth)
                        armorTextY = boxTopY + maskHeight + 3 - (self.Settings.ArmorText.Size / 2)
                    else
                        armorTextY = boxTopY + (totalBoxHeight * 0.001) - (self.Settings.ArmorText.Size / 2)
                    end
                end
                
                box.ArmorText.Position = UDim2.new(0, armorTextX, 0, armorTextY)
                box.ArmorText.Size = UDim2.new(0, 18, 0, self.Settings.ArmorText.Size + 4)
                box.ArmorText.TextSize = self.Settings.ArmorText.Size
                box.ArmorText.Visible = true
            elseif box.ArmorText then
                box.ArmorText.Visible = false
            end
            
            -- Velocity Flag
            if self.Settings.VelocityFlag.Enabled and box.VelocityFlag then
                local velocity = self:CalculateVelocity(player, charCenter)
                box.VelocityFlag.Text = "V:" .. tostring(velocity)
                
                box.VelocityFlag.TextColor3 = self.Settings.VelocityFlag.StaticColor
                
                local velocityTextX = right + self.Settings.VelocityFlag.Offset
                
                local velocityTextY = 0
                if self.Settings.HealthText.FollowBar then
                    local maskHeight = totalBoxHeight * (1 - box.VisualHealth)
                    velocityTextY = boxTopY + maskHeight + 3 - (self.Settings.VelocityFlag.Size / 2)
                else
                    velocityTextY = boxTopY + (totalBoxHeight * 0.001) - (self.Settings.VelocityFlag.Size / 2)
                end
                
                box.VelocityFlag.Position = UDim2.new(0, velocityTextX, 0, velocityTextY)
                box.VelocityFlag.Size = UDim2.new(0, 30, 0, self.Settings.VelocityFlag.Size + 4)
                box.VelocityFlag.TextSize = self.Settings.VelocityFlag.Size
                box.VelocityFlag.Visible = true
            elseif box.VelocityFlag then
                box.VelocityFlag.Visible = false
            end
            
            -- Distance - FIXED: Only show when on screen
            if self.Settings.Distance.Enabled and box.DistanceLabel then
                local firstLabelY = bottom + self.Settings.Distance.Offset.Y - 5
                box.DistanceLabel.Position = UDim2.new(0, left - 1, 0, firstLabelY)
                box.DistanceLabel.Size = UDim2.new(0, width + 2, 0, self.Settings.Distance.Size + 4)
                box.DistanceLabel.Text = "[" .. distance .. "]"
                box.DistanceLabel.TextColor3 = self.Settings.Distance.Color
                box.DistanceLabel.TextSize = self.Settings.Distance.Size
                box.DistanceLabel.Visible = true
            elseif box and box.DistanceLabel then
                box.DistanceLabel.Visible = false
            end
            
        else
            -- Player is offscreen - FIXED: Hide all components including distance label
            if box then
                self:SetBoxVisible(box, false)
            end
            
            -- Disable highlight when not on screen
            if highlight then
                highlight.Enabled = false
            end
        end
    end
end

function ESP:Start()
    if self.Running then 
        self:Stop()
        task.wait(0.1)
    end
    
    self.Running = true
    self:CreateGui()
    
    self.GradientSpinStartTime = tick()
    
    self.Connections.PlayerRemoving = Players.PlayerRemoving:Connect(function(player)
        self:CleanupPlayer(player)
    end)
    
    if self.LoopConnection then
        self.LoopConnection:Disconnect()
    end
    
    self.LoopConnection = RunService.RenderStepped:Connect(function()
        self:Update()
    end)
end

function ESP:Stop()
    self.Running = false
    
    for key, connection in pairs(self.Connections) do
        if typeof(connection) == "RBXScriptConnection" then
            connection:Disconnect()
        end
        self.Connections[key] = nil
    end
    
    if self.LoopConnection then
        self.LoopConnection:Disconnect()
        self.LoopConnection = nil
    end
    
    for player, box in pairs(self.Players) do
        self:CleanupPlayer(player)
    end
    self.Players = {}
    self.HealthStates = {}
    self.LastPositions = {}
    
    -- Clean up all highlights
    for player, highlight in pairs(self.Highlights) do
        if highlight then
            highlight:Destroy()
        end
    end
    self.Highlights = {}
    
    if self.Gui and self.Gui.Parent then
        self.Gui:Destroy()
        self.Gui = nil
    end
end

-- Deep merge function for updating settings
local function deepMerge(t1, t2)
    for k, v in pairs(t2) do
        if type(v) == "table" and type(t1[k]) == "table" then
            deepMerge(t1[k], v)
        else
            t1[k] = v
        end
    end
    return t1
end

function ESP:UpdateSettings(newSettings)
    deepMerge(self.Settings, newSettings)
    
    -- Update all highlights with new settings
    for player, highlight in pairs(self.Highlights) do
        if highlight then
            local teamColor = player.Team and player.Team.TeamColor.Color or self.Settings.Highlight.FillColor
            
            if self.Settings.Highlight.TeamColor then
                highlight.FillColor = teamColor
                if self.Settings.Highlight.UseBoxColor then
                    highlight.OutlineColor = teamColor
                else
                    highlight.OutlineColor = self.Settings.Highlight.OutlineColor
                end
            else
                highlight.FillColor = self.Settings.Highlight.FillColor
                highlight.OutlineColor = self.Settings.Highlight.OutlineColor
            end
            
            highlight.FillTransparency = self.Settings.Highlight.FillTransparency
            highlight.OutlineTransparency = self.Settings.Highlight.OutlineTransparency
        end
    end
    
    -- Recreate all boxes to apply new settings
    for player, box in pairs(self.Players) do
        self:CleanupPlayer(player)
    end
end

function ESP:Toggle(state)
    if state == nil then
        self.Settings.Enabled = not self.Settings.Enabled
    else
        self.Settings.Enabled = state
    end
end

function ESP:Destroy()
    self:Stop()
    
    local folder = CoreGui:FindFirstChild("Folder")
    if folder then
        for _, gui in ipairs(folder:GetChildren()) do
            if gui:IsA("ScreenGui") and gui.Name:find("ESP_") then
                gui:Destroy()
            end
        end
    end
    
    if _G.ESPInstance == self then
        _G.ESPInstance = nil
    end
    
    for k in pairs(self) do
        self[k] = nil
    end
    setmetatable(self, nil)
end

-- Initialize ESP
_G.ESPInstance = ESP
ESP:Start()

-- Module Interface
ESPModule = {
    Toggle = function(state) 
        ESP:Toggle(state) 
    end,
    
    UpdateSettings = function(settings) 
        ESP:UpdateSettings(settings) 
    end,
    
    Stop = function() 
        ESP:Stop() 
    end,
    
    Start = function() 
        ESP:Start() 
    end,
    
    Destroy = function() 
        ESP:Destroy() 
    end,
    
    Settings = ESP.Settings,
    
    -- Helper functions for common operations
    EnableAll = function()
        local settings = {
            Enabled = true,
            Box = {Enabled = true},
            Outline = {Enabled = true},
            HealthBar = {Enabled = true},
            ArmorBar = {Enabled = true},
            HealthText = {Enabled = true},
            ArmorText = {Enabled = true},
            NameTag = {Enabled = true},
            Distance = {Enabled = true},
            Highlight = {Enabled = true},
            VelocityFlag = {Enabled = true}
        }
        ESP:UpdateSettings(settings)
    end,
    
    DisableAll = function()
        local settings = {
            Enabled = false,
            Box = {Enabled = false},
            Outline = {Enabled = false},
            HealthBar = {Enabled = false},
            ArmorBar = {Enabled = false},
            HealthText = {Enabled = false},
            ArmorText = {Enabled = false},
            NameTag = {Enabled = false},
            Distance = {Enabled = false},
            Highlight = {Enabled = false},
            VelocityFlag = {Enabled = false}
        }
        ESP:UpdateSettings(settings)
    end,
    
    -- Color setting helpers
    SetBoxColor = function(color)
        ESP:UpdateSettings({Box = {Color = color}})
    end,
    
    SetHealthBarColor = function(color)
        ESP:UpdateSettings({HealthBar = {Background = color}})
    end,
    
    SetNameTagColor = function(color)
        ESP:UpdateSettings({NameTag = {Color = color}})
    end,
    
    SetHighlightColor = function(fillColor, outlineColor)
        ESP:UpdateSettings({
            Highlight = {
                FillColor = fillColor,
                OutlineColor = outlineColor or fillColor
            }
        })
    end,
    
    -- Transparency setting helpers
    SetBoxTransparency = function(transparency)
        ESP:UpdateSettings({Box = {Transparency = transparency}})
    end,
    
    SetFilledTransparency = function(transparency)
        ESP:UpdateSettings({Box = {FilledTransparency = transparency}})
    end,
    
    SetHealthBarTransparency = function(backgroundTransparency, outlineTransparency)
        ESP:UpdateSettings({
            HealthBar = {
                BackgroundTransparency = backgroundTransparency or 0,
                OutlineTransparency = outlineTransparency or 0
            }
        })
    end,
    
    SetHighlightTransparency = function(fillTransparency, outlineTransparency)
        ESP:UpdateSettings({
            Highlight = {
                FillTransparency = fillTransparency or 0.95,
                OutlineTransparency = outlineTransparency or 0.9
            }
        })
    end,
    
    -- Gradient setting helpers
    SetBoxGradient = function(colors, rotation, spinSpeed)
        ESP:UpdateSettings({
            Box = {
                BoxGradient = true,
                Gradient = {
                    Colors = colors,
                    Rotation = rotation or 90
                },
                GradientSpinSpeed = spinSpeed or 4,
                BoxGradientSpin = spinSpeed ~= nil
            }
        })
    end,
    
    SetHealthBarGradient = function(colors, rotation, lerpSpeed)
        ESP:UpdateSettings({
            HealthBar = {
                UseGradient = true,
                Gradient = {
                    Colors = colors,
                    Rotation = rotation or 90,
                    LerpAnimation = lerpSpeed ~= nil,
                    LerpSpeed = lerpSpeed or 0.028
                }
            }
        })
    end,
    
    SetArmorBarGradient = function(colors, rotation, lerpSpeed)
        ESP:UpdateSettings({
            ArmorBar = {
                UseGradient = true,
                Gradient = {
                    Colors = colors,
                    Rotation = rotation or 90,
                    LerpAnimation = lerpSpeed ~= nil,
                    LerpSpeed = lerpSpeed or 0.028
                }
            }
        })
    end,
    
    -- Individual component toggles
    ToggleBox = function(state) 
        ESP:UpdateSettings({Box = {Enabled = state}})
    end,
    
    ToggleHealthBar = function(state) 
        ESP:UpdateSettings({HealthBar = {Enabled = state}})
    end,
    
    ToggleArmorBar = function(state) 
        ESP:UpdateSettings({ArmorBar = {Enabled = state}})
    end,
    
    ToggleNameTag = function(state) 
        ESP:UpdateSettings({NameTag = {Enabled = state}})
    end,
    
    ToggleHighlight = function(state) 
        ESP:UpdateSettings({Highlight = {Enabled = state}})
    end,
    
    ToggleDistance = function(state) 
        ESP:UpdateSettings({Distance = {Enabled = state}})
    end,
    
    ToggleTeamCheck = function(state) 
        ESP:UpdateSettings({TeamCheck = state})
    end,
    
    -- Get current settings
    GetSettings = function()
        return ESP.Settings
    end,
    
    -- Check if ESP is running
    IsRunning = function()
        return ESP.Running
    end,
    
    -- Enable testing mode
    EnableTestingMode = function()
        ESP:UpdateSettings({TestingMode = true})
    end,
    
    DisableTestingMode = function()
        ESP:UpdateSettings({TestingMode = false})
    end
}

return ESPModule
